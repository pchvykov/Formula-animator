
//SVG text output to give to Colm


/**
	 * Creates a node for the Raphael tree, with all the desired properties
	 * @param {tree node} inp - node from master tree to create the Raphael object for
	 * @param {R.set} parent_set - Raphael set that the node will be in
	 * @param {paper} paper - Raphael paper to add the node to
	 */
function create_node(inp, parent_set, paper){
	
	text_object = paper.text(); //Create text object
	if (inp.data('op') != 'paren') { //handle parenthesis elsewhere
		text_object.id = inp.get_id(); //Create a custom 'ID' attribute which saves the type of node and its ID
		text_object.code = inp.data('code');
		//console.log(inp.data('code'))
		text_object.attr({'text-anchor': 'start'});
	} 
	text_object.parent = parent_set; //Create custom attribute which saves the parent node
	
	return text_object;
}

/**
	 * Scan the master tree and return the Raphael tree for it (but not displayed yet)
	 * @param {tree} input - the master tree
	 * @param {paper} paper - Raphael paper to create tree in
	 */
function scan_tree(input, paper) {
	
	var visit_child = function(node, idx, pset){

		if (node.n_children() == 0){
			pset.push(create_node(node, pset, paper));
		}
		else if (node.data('op') == 'paren'){
			//Left parenthesis
			var pl = create_node(node,pset,paper);
			pl.id = node.get_id();
			pl.code = '(';
			pset.push(pl);

			visit_child(node.child(0), idx, pset);

			//Right parenthesis
			var pr = create_node(node,pset,paper);
			pr.id = node.get_id()+0.1;
			pr.code = ')';
			pset.push(pr);
		}
		else{	
			node.foreach_child(function(child, cidx){
				if(cidx > 0){
					var op = create_node(node,pset,paper);
					op.id += cidx/100; //distinct ids for each instance of the repeated operator (e.g., '+')
					pset.push(op);
				}
				var cset = paper.set();
				pset.push(cset);
				visit_child(child,cidx,cset);
			})

		}
	}
	var node = input.root();
	var pset=paper.set();
	visit_child(node, 0, pset);
	return pset;
}


// function animateAlong(e, p, ms){
// 	var r = e.paper,
// 		len = p.getTotalLength();
// 	r.customAttributes.along = function (v) {
//         var point = p.getPointAtLength(v * len);
//         return {
//             transform: "t" + [point.x, point.y]// + "r" + point.alpha
//         };
//     };
//     e.attr({along: 0});
//     e.animate({along: 1}, ms);  
    
// }

//Test animateAlong function:
/*function test_anim(){
	R=new Raphael($("#formula_container")[0],screen.width, screen.height/2);
	elt = R.circle(0,0,10);
	animateAlong(elt, R.path("M20,20Q60,20,60,60"),1000);
}*/

/**
	 * sets the coordinates of all the nodes in the Raphael tree to their approprate values for displaying
	 * depending on inputs, just sets or animates the elements to these coordiates
	 * @param {set} parent_set - top-most set of the Raphael tree
	 * @param {[number,number]} origin - [x,y] coordinates for starting position of the display
	 * @param {int} fontz - font size to display
	 * @param {bool} flow_fl - flag whether flow into new eq, or just draw it. Following only needed if true:
	 * @param {paper} R_old - Raphael paper containing the orig. eq. to from from
	 * @param {obj} transf - transformation object returned by rule.apply(..)
	 * @param {bool} nice_fl - flag whether to run the quick or the nice animation
	 */
function display_equation(parent_set,origin, fontz, flow_fl, R_old, transf, nice_fl)
{
	//This function parses through the set structure generated by 
	//scan_tree and then displays the text as Raphael SVG text objects. 
	//Basically, it's just a matter of assigning the right coordinates to those text elements that were already generated
	flow_fl = typeof flow_fl !== 'undefined' ? flow_fl : false; //attach gui to object?
	//console.log(flow_fl)
	var font_size = fontz;
	var offset = fontz/3;
	var anim_t = 500, long_anim_t = 2500; //time in ms for the flow animation; long for nice one
	
	// var daddy_element = parent_set[0];
	var R = parent_set.paper;


	//Animate along a path - custom attribute:-----------------
	if(nice_fl){
		//Array to store paths for all the elements
		var paths = [];
		//along: [5, 0.3] - go to 30% of the way along path 5
		R.customAttributes.along = function (n, v) {
	        var point = paths[n].getPointAtLength(v * paths[n].getTotalLength());
	        return {
	            transform: "t" + [point.x, point.y]// + "r" + point.alpha
	        };
	    };
	}


	//The recursive function to draw or animate the equations
	var build_up = function(parent_set, origin){
		if(parent_set.constructor.prototype == Raphael.el) //If it's an element
		{
			elt=parent_set;
			if(elt.code == ')'){
				//console.log('parenthesis', elt.id)
				origin[0]-=offset/2;
			}
			elt.attr(
					{
						text: toUnicodeCharacter(elt.code), 
						"font-size": font_size
					}); //Display the oprator


			//Just display, or flow in from old positions:
			if(!flow_fl){
				elt.attr(
					{
						x: (origin[0] + offset), 
						y: origin[1]
					});
			}
			//Flow:
			else{
				//Find the old ID corresponding to the current new element:
				var old_id = elt.id%1 == 0 ? transf.from(elt.id) : transf.from(Math.floor(elt.id)) + Math.round((elt.id%1)*100)/100;
				start_el = R_old.getById(old_id);
				//console.log('ids:', elt.id, old_id)
				if(start_el != null){
					//Set the starting position to that in the old equation:
					elt.attr(
						{
							x: start_el.attr('x'),
							y: start_el.attr('y')
						});

					//nice animation, or just straight move in
					if (nice_fl ){

						//condition on type of transformation goes here - assume disribution for now

						//Create an array with all ids of the expression being moved
						var d_ids = [];
						forEl(R_old.getById(transf.get('top')).parent, function(el){d_ids.push(el.id)})
						//console.log(d_ids);
						//console.log(elt.id);

						//check if the current element is in the part being moved, and animate along a path
						if(d_ids.indexOf(old_id)>-1){
							//console.log('in');

							//Create the path for animation:
							var	Ex=(origin[0] + offset)-elt.attr('x'), Ey = origin[1]-elt.attr('y'),
								midx = Ex/2, midy = -80;
							//console.log('in',elt.id, Ex)
							var p  = R.path("M" + 0 + "," + 0 + "Q" + midx + "," + midy + "," + Ex + "," + Ey);
							p.attr({opacity:0});

							//Animate along path[n] = p:
							var n = paths.length;
							paths.push(p);
							elt.attr({along: [n, 0]});
    						elt.animate({along: [n, 1]}, long_anim_t);  
							//animateAlong(elt, path, long_anim_t);
						}
						//Straight animation for everything not being distributed
						else{
							elt.animate(
							{
								x: (origin[0] + offset), 
								y: origin[1]
							},long_anim_t);
						}
					}
					//straight animation for roll-over proposed transformation
					else{
						elt.animate(
							{
								x: (origin[0] + offset), 
								y: origin[1]
							},anim_t,"bounce");
					}
				}
				else{ // if element was not present in the original, fade it in
					elt.attr(
					{
						x: (origin[0] + offset), 
						y: origin[1],
						opacity:0
					});
					var fade = Raphael.animation({opacity:1}, anim_t);
					if (nice_fl) elt.animate(fade.delay(long_anim_t-anim_t));
					else elt.animate(fade);
				}
			}

			var new_origin = [elt.getBBox().width + origin[0] + offset, origin[1]];
			if(elt.code == '('){
				new_origin[0]-=offset/2;
			}
			return new_origin;
		}
		else //Set it's a set
		{
			
			for(var i=0; i<parent_set.length; i++){
				origin = build_up(parent_set[i],origin);
			}
			return origin;
				
		}

	}

	build_up(parent_set,origin);
}


/**
	 * does everything to display a formula
	 * @param {tree} form - master (backend) tree
	 * @param {[number,number]} origin - [x,y] coordinates for starting position of the display
	 * in paper or in window; default: [30,300]
	 * @param {bool} gui_fl - make the objects interactive? (dragging, dropping, etc.); default: false
	 * @param {paper} R - Raphael paper; default: creates a new paper at the location in window given by origin
	 * @param {int} fontz - font size, default: 30
	 */
function draw_it(form, origin, gui_fl, R, fontz){
	//Defaults:
	//form - original eqaution tree
	origin = typeof origin !== 'undefined' ? origin : [30,300]; //origin coord. in Paper (or in window)
	gui_fl = typeof gui_fl !== 'undefined' ? gui_fl : false; //attach gui to object?
	if(typeof R === 'undefined'){ //raphael paper to put it in (optional)
		R = Raphael(origin[0], origin[1], 400, 50); 
		origin = [10, 10];
	}
	fontz = typeof fontz !== 'undefined' ? fontz : 30; //font size
	

	R.canvas.style.backgroundColor = '#FFF';

    var v = scan_tree(form, R);

    display_equation(v, origin, fontz);
    if(gui_fl) {set_gui(v, form, R);}

    //Return set of all objects in the paper
    return v;
}


/**
	 * does everything to flow in to a formula
	 * @param {paper} R_old - Raphael paper containing the old equation - to animate from
	 * @param {tree} f_new - backend tree for the new formula
	 * @param {obj} transf - transformation object returned by rule.apply(..)
	 * @param {bool} nice_fl - flag whether to run the quick or the nice animation. true also sets gui.
	 */
function flow_it(R_old, f_new, transf, nice_fl){
	var R = new Raphael($("#formula_container")[0],screen.width, screen.height/2);
	var v = scan_tree(f_new, R);
	display_equation(v, main_eq.origin, main_eq.fontz, true, R_old, transf, nice_fl);
	if(nice_fl) {set_gui(v, f_new, R);}
	return v;
}